+ .bss 段： 存储未初始化的全局变量和静态变量(必须初始化为 0 )，程序加载的时候 BSS 段只占用 符号表空间，不占用文件空间，与.data 段不同
+ .data 段 ：已初始化的数据段，不管是静态的还是非静态的，可以读写，并且程序启动的时候从可执行文件加载初始值
+ .text 段（代码段）：存储可执行的机器指令，包括所有可执行的机器指令，所有函数的机器码，这个段是只读的 ，并且可以被多个进程恭共享
+ .rodata  : 只读数据段，字符字面量以及 const 变量，只读，写入时会触发段错误
+ 堆（heap) :  void * ptr = malloc(1024) 可以动态分配内存，通过 malloc 和 free 来管理，地址递增
+ 栈（Stack) : 存储局部变量，函数参数以及返回地址，函数调用时自动管理，地址递减

**内存布局图**

高地址
┌─────────────┐
│    栈       │ ← sp 指向这里，向下增长
│     ↓       │
├─────────────┤
│             │
│   未使用    │
│             │
├─────────────┤
│     ↑       │
│    堆       │ ← malloc 分配，向上增长
├─────────────┤
│  .bss 段    │ ← 未初始化全局变量（清零）
├─────────────┤
│  .data 段   │ ← 已初始化全局变量
├─────────────┤
│  .rodata 段 │ ← 只读数据/常量
├─────────────┤
│  .text 段   │ ← 代码段（你的 entry.S）
└─────────────┘
低地址 (0x80000000)

---

# 设置栈指针指向每个 CPU 的栈区域
la sp, stack0              # stack0 在 .bss 或 .data 段
li a0, 1024*4             # 常量 4096 编译后在 .text 段
csrr a1, mhartid          # 这条指令本身在 .text 段

# ...

call start                # 调用 .text 段中的 start 函数

+ 其中汇编代码在 .text 段
+ stack0 在 .bss 段或者 .data 段

---

ENTRY ( _entry ) : 指定程序的入口点为 _entry 符号，告诉链接器程序应该从哪里开始执行，qemu 加载内核之后，  PC 会被设置为 _entry 的地址



qemu 的 -kernel 参数会将内核加载到 0x8000000 ，这是riscv 平台的标准内核加载地址，在kernel.ld 中指定 . = 0x80000000

---

## 内存布局方案

```c
#ifndef MEMLAYOUT_H
#define MEMLAYOUT_H

// 物理内存布局
#define KERNBASE     0x80000000L  // 内核起始地址
#define PHYSTOP      0x88000000L  // 物理内存结束 (128MB)

// 虚拟内存布局
#define MAXVA        (1L << (9 + 9 + 9 + 12 - 1))  // 最大虚拟地址
#define TRAMPOLINE   (MAXVA - PGSIZE)               // trampoline 页
#define TRAPFRAME    (TRAMPOLINE - PGSIZE)          // trapframe 页

// 用户空间布局
#define USTACKBASE   0x000000003FFFF000L  // 用户栈基址
#define USTACKTOP    0x0000000040000000L  // 用户栈顶

// 内核空间布局
#define KSTACK(p)    ((p) * 2 * PGSIZE + KERNBASE + 0x1000000)  // 内核栈

// 设备地址映射
#define UART0        0x10000000L
#define VIRTIO0      0x10001000L
#define CLINT        0x2000000L
#define PLIC         0x0c000000L

#define PGSIZE       4096
#define PGSHIFT      12

#endif
```

---

## 启动入口代码

```assembly
.section .text
.global _entry
_entry:
    # 设置每个 CPU 的启动栈
    la sp, stack0
    li a0, 1024*4      # 4KB 栈大小
    csrr a1, mhartid   # 获取 CPU ID
    addi a1, a1, 1
    mul a0, a0, a1
    add sp, sp, a0
    
    # 跳转到 C 代码
    call start
    
spin:
    j spin

.section .data
.align 12
stack0:
    .space 4096 * 8  # 8 个 CPU 的启动
```

---



## 内核启动顺序

1. **硬件启动** → QEMU 加载内核到 0x80000000
2. **汇编入口** → entry.S 设置栈，跳转到 start
3. **机器模式初始化** → start.c 设置特权模式和定时器
4. **内核主初始化** → main.c 初始化所有子系统
5. **多核启动** → 启动其他 CPU 核心
6. **用户进程** → 创建 init 进程，进入用户态

---

## 启动流程图

```graph TD
    A[QEMU 启动] --> B[加载 kernel 到 0x80000000]
    B --> C[所有 CPU 跳转到 _entry]
    C --> D[entry.S: 设置栈]
    D --> E[call start]
    E --> F[start.c: 机器模式初始化]
    F --> G[call main]
    G --> H[main.c: 内核主初始化]
    H --> I[启动其他 CPU]
    I --> J[scheduler: 进入调度循环]
    J --> K[userinit: 创建第一个进程]
    K --> L[用户态运行]
```

## 调用链分析

1. 汇编启动（ kernel / entry.S)
2. 机器模式初始化(kernel / start.c)
3. 内核主初始化 （kernel / main.c)

---

## 第一阶段，基础的启动文件

```assembly
kernel/
├── entry.S          # 汇编启动入口
├── start.c          # 机器模式初始化  
├── main.c           # 内核主初始化
├── uart.c           # 串口驱动
├── kernel.ld        # 链接脚本
├── types.h          # 基本类型定义
├── param.h          # 系统参数
├── riscv.h          # RISC-V 相关定义
└── memlayout.h      # 内存布局

Makefile             # 构建脚本
```

### start.c（底层硬件抽象）：

- 处理CPU特权模式、中断控制等**硬件相关**的事务
- 为上层提供一个**抽象的硬件环境**
- 这部分代码通常是**架构相关**的（RISC-V特有）

### main.c（系统服务协调）：

- 协调各个操作系统子系统的初始化顺序
- 管理系统的**整体状态转换**
- 这部分代码通常是**架构无关**的（可移植）

### uart.c（设备驱动）：

- 专门负责一个特定硬件设备的控制
- 为上层提供**设备无关**的接口
- 这部分代码是**设备相关**的（UART特有）

这种分层设计的好处：

- **职责清晰**：每个文件负责特定层次的功能
- **可维护性**：修改一个层次不影响其他层次
- **可移植性**：移植到其他架构时只需修改特定层次
- **可扩展性**：添加新功能时有明确的放置位置

---

**实验一 ：RISC-V 引导与裸机启动 **

1. ***为什么要设置栈（内核栈) :*** 

   >  用于存储局部变量以及番薯调用返回地址

2. **栈应该要设置多大 ：**

   >  4096 byte 也就是 4 kb ， **why ？** 一个内存页面的标准大小，而且可以容纳足够神的调用层次，可以存储寄存器的保存和恢复的需要，

3. **各个内存段的作用和排列顺序如下 ：** 

   ```assembly
   ┌─────────────────┐ ← 0x80000000 (KERNBASE)
   │   .text 段      │ ← 代码段
   │   (可执行代码)   │   - main(), printf() 等函数
   ├─────────────────┤ ← etext
   │   .rodata 段    │ ← 只读数据段
   │   (常量数据)     │   - 字符串字面量 "Hello"
   │                │   - const 变量
   ├─────────────────┤
   │   .data 段      │ ← 已初始化数据段
   │   (初始化全局变量)│   - int global_var = 42;
   ├─────────────────┤ ← edata
   │   .bss 段       │ ← 未初始化数据段
   │   (未初始化全局变量)│ - int uninitialized_var;
   ├─────────────────┤ ← end
   │   堆区域        │ ← 动态分配 (kalloc)
   │   (向上增长)     │
   │   ↑            │
   │                │
   │   ↓            │
   │   栈区域        │ ← 函数调用栈
   │   (向下增长)     │
   └─────────────────┘ ← 高地址
   ```

4. **为什么第一条指令是设置栈指针**

   > cpu 刚启动的时候，如果不设置栈，直接调用函数 call start ，返回指针就会随机写入地址，所以首先应该设置栈指针`la sp ,stack0 + (4096 * 4)`，然后才能安全地写入返回地址，安全地调用函数

5. **为什么要清零 .bss 段**

   > 相当于是给没有初始化的声明周期比较长的数据（静态变量，全局变量）一个默认的初始零值，不然如果没有初始化就使用时(虽然不推荐这么做) 会出现随机垃圾数据
   >
   > 在代码中的具体实现为 
   >
   > ```c
   > // 函数的作用是 给地址 dst 之后的n 个字节都赋值为 c
   > void * memset(void * dst, int c,uint n){
   >     char *cdst = (char *) dst;
   >     for(int i = 0 ; i < n ; i++){
   >         cdst[i] = c;
   >     }
   >     return dst;
   > }
   > // 调用 memset 来清零 edata 到 end 的区域
   > memset(edata,0,end - edata);
   > ```

6. **ENTRY(_entry) 的作用**

   > 告诉链接器连接入口是 _entry 符号，确定整个程序的其实入口是 _entry

7. **etext，edata,end 符号的作用**

   >  其实就是各个段起始和终结地址，注意这写内存都是静态分配的，根据 kernel.ld 脚本直接操作的，并且代码中的变量在编译阶段就确定了内存中的位置

8. **最简单串口输出需要配置哪些寄存器**

   > ```c
   > #define RHR 0  // 接收保持寄存器
   > #define THR 0  // 发送保持寄存器  
   > #define IER 1  // 中断使能寄存器
   > #define FCR 2  // FIFO控制寄存器
   > #define LCR 3  // 线路控制寄存器
   > #define LSR 5  // 线路状态寄存器
   > ```
   >
   > 

9. **输出一个字符的完整流程**

   > 首先是初始化步骤，对uart 串口进行初始化，
   >
   > 禁用中断 - 设置波特率 - 设置 8 位数据 - 启用并且清空 FIFO 
   >
   > 发送一个字符时 首先等待发送寄存器空闲，空闲时将字符写到对应的寄存器，发送字符串就是循环发送字符

   

---

## 实验二 ： 内核 printf 与清屏功能实现

1. **xv6 为什么不是使用递归进行数字转换？**

   > 每次递归调用占用很多栈空间，并且函数调用开销比较大，不如循环安全

2. **`printint() 中处理 INT_MIN 的技巧`**

   > 首先需要清楚，在二进制补码系统中，INT_MIN 和 - INT_MIN 的二进制表示方式一样，所以其实是可以直接用 unsigned int 来正确地接受的，所以完全一开始就提取符号，然后转换为无符号数来表示

3. **printint()如何处理不同进制之间的转换**

   > 通过不断对 base 取余 (得到最低位) 然后除以 base（丢弃最低位) 然后拼接来实现

4. **printf 如何解析格式字符串**

   > 首先printf 函数是基于可变参数来实现的，第一个参数是格式化字符串的首地址指针，后面是可变参数，通过 va_list 类型来维护，va_start(ap,fmt) 用于将ap 变量绑定到 fmt 之后的参数，然后通过循环每次获取 fmt 的一个字符也就是一个字节 ，通过 0xff 掩码来实现，如果是普通字符就直接打印，遇到转义字符 % 就会判断不同的情况，通过 c0 c1 c2 分别消耗原来格式化 字符串中的字符 % 以及之后的可能会有的字符，为什么是两个呢，因为% 之后的占位符最多只有两个

5. **如何实现线程安全的printf**

   > 加互斥锁来访问临界资源

6. **画出系统的架构图**

   > ```assembly 
   > 应用层    │  printf("Hello %d\n", 42);
   >          │  panic("system error");
   >          │
   > 格式层    │  printf() ──┐
   >          │             ├─── printint()
   >          │             ├─── printptr()  
   >          │             └─── consputc()
   >          │
   > 控制台层  │  console_putc() ──┐
   >          │                  ├─── 缓冲管理
   >          │                  ├─── 特殊字符处理
   >          │                  └─── 多设备路由
   >          │
   > 硬件层    │  uart_putc() ────── UART 寄存器操作
   > ```
   >
   > // 硬件层 
   >
   > ```c
   > void uart_putc(char c);
   > int uart_getc(void);
   > void uart_init(void);
   > ```
   >
   > // 控制台层
   >
   > ```c
   > void console_putc(char c);
   > void console_puts(const char *s);
   > void console_init(void);
   > ```
   >
   > // 格式化接口层
   >
   > ```c
   > int printf(char * fmt, ...);
   > int snprintf(char * buf,int size,char *fmt,...);
   > void panic(char *s);
   > ```

7. **是否需要缓冲区**

   > xv6 没有选择使用缓冲区，而是直接调用，没有进行批量优化

8. **处理格式化错误**

   > 未知格式直接打印，方便调试



---

## 实验三 ： 页表管理

1. **39位虚拟地址中各个VPN 段的作用是什么？**

   > 前三个 9 位的 VPN 分别表示的是三级页表，最后的12位为页内偏移，为什么是 9  位 ？ 因为一页刚好是 512 个表项，所以一级页表可以直接使用一页来存储

2. **pte 页表项的布局**

   > // PTE 格式 (64位)
   > ┌─────────────┬─────┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
   > │   PPN       │ RSW │G│A│D│R│W│X│U│V│ │
   > │  [53:10]    │[9:8]│7│6│5│4│3│2│1│0│ │
   > └─────────────┴─────┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
   >
   > // xv6 中的定义
   > #define PTE_V (1L << 0)   // Valid：页表项有效
   > #define PTE_R (1L << 1)   // Read：可读
   > #define PTE_W (1L << 2)   // Write：可写  
   > #define PTE_X (1L << 3)   // eXecute：可执行
   > #define PTE_U (1L << 4)   // User：用户态可访问
   > #define PTE_A (1L << 6)   // Accessed：已访问
   > #define PTE_D (1L << 7)   // Dirty：已修改

3. **中间级页表项的读写执行权限应该如何设置？**

   > 不设置，应为中间级页表的作用是访问下一级页表，不涉及各项权限，只有 V位来表示是否有效

4. **页表也存储在物理内存中的理解**

   > 每个进程会有自己的页表，需要操作系统分配内存空间存放页表，其本身只是普通的物理页面，存放页面相关信息

5. **kalloc.c 中元数据 struct run 设计有什么巧妙之处？，为什么不需要额外的元数据存储 ？**

   > 这个结构体里面只有下一个页面的指针，而且存储位置是在每一个空闲页表的开头，不额外占用空间，并且每次写页表都会把这个数据覆盖

6. **空闲页链表如何构建？**

   > 首先在 kmem 结构体中维护了指向空闲链表头的指针 freelist, 具体来说，他是一个指向第一个空闲页的页首地址的指针，每次新增空闲页的时候采用头插的方式插入

7. **如何确定可分配的内存范围？**

   > 顺序遍历一次空闲分区链

8. **为什么要按页对齐？**

   > 方便组织和操作空闲页

9. **现有分配算法的时间复杂度？**

   > 因为原始的xv6 系统采用空闲分区链来实现，所以分配算法的时间复杂度为 O(1),

10. **如何防止 double-free？**

    > 目前只是基础的边界检查和填充垃圾数据，将数据全部填1，但是现在的xv6 对于 double-free 的防护非常有限，无法察觉double- free 后果就是连续两次的 free 会导致同一片内存空间在空闲分区链中出现两次

11. **xv6 设计的优缺点**

    > 设计简单，额外空间需要很少，容易实现，缺点是功能简单，一次只能分配一个页面大小的内存空间，并且做不到连续分页，容易产生内存碎片

12. **我的物理内存分配实现**

    > 采用buddy 伙伴系统，在 .bss 段中分配了两处结构体空间，然后在对空间中 分配 pages 数组以及 bitmap 位图，在 buddy 结构体中，存放一个数组，包含十个 order ，分别表示指向对应二次幂的块的指针 
    >
    > // 详细的内核内存布局：
    >
    > KERNBASE (0x80000000)
    >     ┌─────────────────────┐
    >     │   .text (代码段)     │  ← 内核代码，只读
    >     ├─────────────────────┤
    >     │   .rodata (只读数据) │  ← 字符串常量
    >     ├─────────────────────┤
    >     │   .data (数据段)     │  ← 已初始化全局变量
    >     ├─────────────────────┤
    >     │   .bss (BSS段)      │  ← 未初始化全局变量
    >     │                     │    包括：buddy 结构体
    >     │                     │          kmem 结构体  
    >     │                     │          其他全局变量
    > end[] ─────────────────────┤
    >     │                     │
    >     │   pages 数组         │  ← struct page_info pages[]
    >     │                     │    大小：total_pages * sizeof(page_info)
    >     ├─────────────────────┤
    >     │   bitmap 位图        │  ← buddy.bitmap
    >     │                     │    大小：(total_pages + 7) / 8 字节
    > adjusted_start ────────────┤
    >     │                     │
    >     │   可分配页面区域     │  ← 伙伴系统管理的区域
    >     │                     │    这部分才会被分页管理
    >     │                     │
    >     │                     │
    > PHYSTOP ───────────────────┘
    >
    > 分配完 pages 数组的空间以及 bitmap 的空间之后，重新划分 堆空间的起点，完成空闲链表的初始化

    > 一些实现细节，在 buddy_system 结构体中，我使用 struct free_block free_list[MAX_ORDER + 1] 来在栈中创建创建一个结构体数组之后，系统会自动零初始化，后面可以直接调用访问数组结构体元素中的数据，而且这里是自动创建的节点我们视为哑结点